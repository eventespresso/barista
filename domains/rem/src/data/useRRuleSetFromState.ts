import { RRule, RRuleSet } from 'rrule';
import { parseISO } from 'date-fns';

import useFormState from './useFormState';

/**
 * This pattern is used to replace COUNT in rrule to generate 500 dates
 * to make sure enough dates are generated to be able to remove dates generated by exRule
 *
 * We could use positive lookaround zero-length assertions like
 * const COUNT_REGEX = /(?<=COUNT=)[0-9]+?(?=;)/; and then simply write
 * const COUNT_REPLACE = '500';
 * but lookbehinds in JavaScript are not supported by all browsers yet (at the time of writing)
 * and Babel cannot transform them ¯\_(ツ)_/¯
 * @link https://www.regular-expressions.info/javascript.html
 */
const COUNT_REGEX = /COUNT=[0-9]+?;/; // matches "COUNT=8;", "COUNT=50;", "COUNT=102;" etc.
const COUNT_REPLACE = 'COUNT=500;';

/**
 * Return an instance of RRuleSet with the rules set from REM state
 */
const useRRuleSetFromState = (rRuleString?: string): RRuleSet => {
	const { exRule, rRule, exDates, rDates } = useFormState();
	const rruleSet = new RRuleSet();

	// clone the string
	let rRuleToUse = String(rRuleString || '');

	if (!rRuleToUse && rRule) {
		// set COUNT to a higher value to generate plenty of dates
		rRuleToUse = rRule.replace(COUNT_REGEX, COUNT_REPLACE);
	}

	rruleSet.rrule(RRule.fromString(rRuleToUse));

	if (exRule) {
		rruleSet.exrule(RRule.fromString(exRule));
	}

	rDates.forEach((rDate) => {
		rruleSet.rdate(parseISO(rDate));
	});

	exDates.forEach((exDate) => {
		rruleSet.exdate(parseISO(exDate));
	});

	return rruleSet;
};

export default useRRuleSetFromState;
