import { useMemo } from 'react';

import { __ } from '@eventespresso/i18n';
import { getEEDomData, useTimeZoneTime } from '@eventespresso/services';
import { CalendarOutlined, ControlOutlined, ProfileOutlined } from '@eventespresso/icons';
import { Ticket } from '@eventespresso/edtr-services';

import type { EspressoFormProps } from '@eventespresso/form';

import { ticketSalesEndFields } from './ticketSalesEndFields';
import { ticketSalesStartFields } from './ticketSalesStartFields';
import { validate } from './formValidation';

import { RemTicket, useFormState } from '../../data';
import { normalizeTicketForRem } from '../../utils';

type TicketFormConfig = EspressoFormProps<RemTicket>;

const VISIBILITY_OPTIONS = getEEDomData('eventEditor')?.ticketMeta?.visibilityOptions;

const useTicketFormConfig = (ticket?: RemTicket | Ticket, config?: Partial<TicketFormConfig>): TicketFormConfig => {
	const { utcToSiteTime } = useTimeZoneTime();
	const { tickets } = useFormState();

	const initialValues = useMemo(() => {
		const normalizedTicket = normalizeTicketForRem(ticket, utcToSiteTime);
		return {
			...normalizedTicket,
			// set initial prices from REM state
			prices: tickets?.[ticket?.id]?.prices,
		};
	}, [ticket, tickets, utcToSiteTime]);

	return useMemo(
		() => ({
			...config,
			initialValues,
			onSubmit: config?.onSubmit,
			subscription: {},
			validate,
			layout: 'horizontal',
			debugFields: ['values', 'errors'],
			sections: [
				{
					name: 'basics',
					icon: ProfileOutlined,
					title: __('Basics'),
					fields: [
						{
							name: 'name',
							label: __('Name'),
							fieldType: 'text',
							min: 3,
							required: true,
						},
						{
							name: 'description',
							label: __('Description'),
							fieldType: 'simple-text-editor',
						},
						{
							name: 'isShared',
							label: __('Shared Ticket'),
							fieldType: 'switch',
							info: __(
								'If enabled, a single ticket will be created and assigned to ALL datetimes generated by the recurrence editor. The shared ticket will therefore grant access to ALL of the datetimes. Otherwise a new ticket will be created and assigned to each datetime and only grant access to the datetime it is assigned to.'
							),
							width: 'small',
						},
					],
				},
				{
					name: 'salesStart',
					icon: CalendarOutlined,
					title: __('Ticket Sales Start'),
					fields: [
						{
							name: 'ticketSalesDates.startDate' as 'startDate',
							label: '',
							fieldType: 'datetimepicker',
							conditions: [{ field: 'isShared', compare: '=', value: true }],
						},
						{
							columns: 4,
							name: 'ticketSalesStart',
							label: '',
							fieldType: 'group',
							conditions: [{ field: 'isShared', compare: '=', value: false }],
							subFields: ticketSalesStartFields,
						},
					],
				},
				{
					name: 'salesEnd',
					icon: CalendarOutlined,
					title: __('Ticket Sales End'),
					fields: [
						{
							name: 'ticketSalesDates.endDate' as 'endDate',
							label: '',
							fieldType: 'datetimepicker',
							conditions: [{ field: 'isShared', compare: '=', value: true }],
						},
						{
							columns: 4,
							name: 'ticketSalesEnd',
							label: '',
							fieldType: 'group',
							conditions: [{ field: 'isShared', compare: '=', value: false }],
							subFields: ticketSalesEndFields,
						},
					],
				},
				{
					name: 'details',
					icon: ControlOutlined,
					title: __('Details'),
					fields: [
						{
							name: 'quantity',
							label: __('Quantity For Sale'),
							fieldType: 'number',
							parseAsInfinity: true,
							max: 1000000,
							min: -1,
							info:
								__('The maximum number of this ticket available for sale.') +
								'\n' +
								__('Set to 0 to stop sales, or leave blank for no limit.'),
							width: 'small',
						},
						{
							name: 'uses',
							label: __('Number of Uses'),
							fieldType: 'number',
							parseAsInfinity: true,
							max: 1000,
							min: 0,
							info:
								__(
									'Controls the total number of times this ticket can be used, regardless of the number of dates it is assigned to.'
								) +
								'\n' +
								__(
									'Example: A ticket might have access to 4 different dates, but setting this field to 2 would mean that the ticket could only be used twice. Leave blank for no limit.'
								),
							width: 'small',
						},
						{
							name: 'min',
							label: __('Minimum Quantity'),
							fieldType: 'number',
							max: 1000000,
							min: 0,
							info:
								__(
									'The minimum quantity that can be selected for this ticket. Use this to create ticket bundles or graduated pricing.'
								) +
								'\n' +
								__('Leave blank for no minimum.'),
							width: 'small',
						},
						{
							name: 'max',
							label: __('Maximum Quantity'),
							fieldType: 'number',
							parseAsInfinity: true,
							max: 1000000,
							min: -1,
							info:
								__(
									'The maximum quantity that can be selected for this ticket. Use this to create ticket bundles or graduated pricing.'
								) +
								'\n' +
								__('Leave blank for no minimum.'),
							width: 'small',
						},
						{
							name: 'visibility',
							label: __('Visibility'),
							fieldType: 'select',
							info: __('Where the ticket can be viewed throughout the UI.'),
							options: VISIBILITY_OPTIONS,
						},
						{
							name: 'isRequired',
							label: __('Required Ticket'),
							fieldType: 'switch',
							info: __(
								'If enabled, the ticket must be selected and will appear first in frontend ticket lists.'
							),
							width: 'small',
						},
					],
				},
			],
		}),
		[config, initialValues]
	);
};

export default useTicketFormConfig;
